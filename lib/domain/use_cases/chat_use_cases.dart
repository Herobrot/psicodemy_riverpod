import '../entities/chat_entity.dart';
import '../repositories/chat_repository_interface.dart';

class ChatUseCases {
  final ChatRepository _chatRepository;

  ChatUseCases(this._chatRepository);

  // Chat management use cases
  Future<List<ChatEntity>> getChats() async {
    return await _chatRepository.getChats();
  }

  Future<ChatEntity?> getChatById(String chatId) async {
    return await _chatRepository.getChatById(chatId);
  }

  Future<ChatEntity> createChat({
    required String name,
    required List<String> participantIds,
    required ChatType type,
    String? description,
  }) async {
    final chat = ChatEntity(
      id: '', // Will be generated by repository
      name: name,
      description: description,
      type: type,
      createdAt: DateTime.now(),
      updatedAt: DateTime.now(),
      participantIds: participantIds,
    );
    return await _chatRepository.createChat(chat);
  }

  Future<void> leaveChat(String chatId, String userId) async {
    await _chatRepository.leaveChat(chatId, userId);
  }

  // Message use cases
  Future<List<MessageEntity>> getMessages(String chatId, {int limit = 50}) async {
    return await _chatRepository.getMessages(chatId, limit: limit);
  }

  Future<MessageEntity> sendMessage({
    required String chatId,
    required String senderId,
    required String content,
    MessageType type = MessageType.text,
    String? replyToMessageId,
    List<String>? attachmentUrls,
  }) async {
    final message = MessageEntity(
      id: '', // Will be generated by repository
      chatId: chatId,
      senderId: senderId,
      content: content,
      type: type,
      createdAt: DateTime.now(),
      replyToMessageId: replyToMessageId,
      attachmentUrls: attachmentUrls,
    );
    return await _chatRepository.sendMessage(message);
  }

  Future<MessageEntity> editMessage(String messageId, String newContent) async {
    // First get the message
    final messages = await _chatRepository.getMessages(''); // This would need to be refactored
    final message = messages.firstWhere((m) => m.id == messageId);
    
    final updatedMessage = MessageEntity(
      id: message.id,
      chatId: message.chatId,
      senderId: message.senderId,
      content: newContent,
      type: message.type,
      createdAt: message.createdAt,
      updatedAt: DateTime.now(),
      replyToMessageId: message.replyToMessageId,
      isRead: message.isRead,
      isEdited: true,
      isDeleted: message.isDeleted,
      attachmentUrls: message.attachmentUrls,
      metadata: message.metadata,
    );
    
    return await _chatRepository.updateMessage(updatedMessage);
  }

  Future<void> deleteMessage(String messageId) async {
    await _chatRepository.deleteMessage(messageId);
  }

  Future<void> markChatAsRead(String chatId) async {
    await _chatRepository.markChatAsRead(chatId);
  }

  // Search use cases
  Future<List<MessageEntity>> searchMessages(String query, {String? chatId}) async {
    return await _chatRepository.searchMessages(query, chatId: chatId);
  }

  Future<List<ChatEntity>> searchChats(String query) async {
    return await _chatRepository.searchChats(query);
  }

  // Real-time streams
  Stream<List<ChatEntity>> watchChats() {
    return _chatRepository.watchChats();
  }

  Stream<List<MessageEntity>> watchMessages(String chatId) {
    return _chatRepository.watchMessages(chatId);
  }

  Stream<MessageEntity> watchNewMessages(String chatId) {
    return _chatRepository.watchNewMessages(chatId);
  }
} 